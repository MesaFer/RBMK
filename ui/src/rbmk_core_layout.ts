/**
 * RBMK-1000 Core Layout Generator
 * Based on OPB-82 second generation reactor after modernization
 * 
 * Core structure:
 * - 48x48 grid of graphite blocks (25x25 cm each)
 * - Non-circular core boundary defined by actual channel positions from JSON config
 * - Total 1884 channels in actual RBMK arrangement
 * 
 * Channel types:
 * - TK (1661): Technological channels (fuel assemblies)
 * - RR (146): Manual control rods
 * - AR (8): Automatic control rods
 * - USP (24): Shortened absorber rods (from below)
 * - LAR (12): Local automatic control rods
 * - AZ (33): Emergency protection rods
 * 
 * Positions loaded from config/opb82_layout.json (generated by parse_opb82_scheme.py)
 */

export type ChannelType = 'TK' | 'RR' | 'AR' | 'USP' | 'LAR' | 'AZ' | 'GRAPHITE';

export interface CoreChannel {
    id: number;
    type: ChannelType;
    gridX: number;  // 0-47 grid position
    gridY: number;  // 0-47 grid position
    x: number;      // cm from center
    y: number;      // cm from center
}

// Grid spacing in cm (25x25 cm graphite blocks)
const GRID_SPACING = 25.0;
const GRID_SIZE = 48;

// Channel colors for visualization (based on OPB-82 scheme legend)
export const CHANNEL_COLORS = {
    TK: { r: 0.5, g: 0.5, b: 0.5 },         // Gray - technological channels (fuel)
    RR: { r: 1.0, g: 1.0, b: 1.0 },         // White - manual control rods
    AR: { r: 0.0, g: 0.69, b: 0.57 },       // Teal #01B191 - automatic control rods (8 rods)
    USP: { r: 1.0, g: 0.85, b: 0.0 },       // Yellow #FED801 - shortened absorber rods
    LAR: { r: 0.0, g: 0.4, b: 0.81 },       // Blue #0067CE - local automatic control rods (12 rods)
    AZ: { r: 0.87, g: 0.1, b: 0.01 },       // Red #DE1A03 - emergency control rods
    GRAPHITE: { r: 0.4, g: 0.4, b: 0.45 },  // Gray - graphite moderator
};

// ============================================================================
// JSON Config Interface
// ============================================================================

interface CellData {
    grid_x: number;
    grid_y: number;
    original_grid_x: number;
    original_grid_y: number;
    pixel_x: number;
    pixel_y: number;
    area: number;
}

interface LayoutConfig {
    metadata: {
        image_size: { width: number; height: number };
        cell_size: number;
        total_cells: number;
        grid_size: { width: number; height: number };
    };
    cells: {
        AZ: CellData[];
        TK: CellData[];
        RR: CellData[];
        AR: CellData[];
        LAR: CellData[];
        USP: CellData[];
    };
}

// ============================================================================
// Layout data loaded from JSON config
// ============================================================================

let layoutConfig: LayoutConfig | null = null;
let positionSets: {
    az: Set<string>;
    ar: Set<string>;
    lar: Set<string>;
    usp: Set<string>;
    rr: Set<string>;
    tk: Set<string>;
    all: Set<string>;
} | null = null;

/**
 * Load layout configuration from JSON file
 */
export async function loadLayoutConfig(configPath: string = '/config/opb82_layout.json'): Promise<void> {
    try {
        const response = await fetch(configPath);
        if (!response.ok) {
            throw new Error(`Failed to load config: ${response.status} ${response.statusText}`);
        }
        layoutConfig = await response.json();
        
        // Build position sets for fast lookup
        positionSets = {
            az: new Set<string>(),
            ar: new Set<string>(),
            lar: new Set<string>(),
            usp: new Set<string>(),
            rr: new Set<string>(),
            tk: new Set<string>(),
            all: new Set<string>(),
        };
        
        if (layoutConfig) {
            for (const cell of layoutConfig.cells.AZ) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.az.add(key);
                positionSets.all.add(key);
            }
            for (const cell of layoutConfig.cells.AR) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.ar.add(key);
                positionSets.all.add(key);
            }
            for (const cell of layoutConfig.cells.LAR) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.lar.add(key);
                positionSets.all.add(key);
            }
            for (const cell of layoutConfig.cells.USP) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.usp.add(key);
                positionSets.all.add(key);
            }
            for (const cell of layoutConfig.cells.RR) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.rr.add(key);
                positionSets.all.add(key);
            }
            for (const cell of layoutConfig.cells.TK) {
                const key = `${cell.grid_x},${cell.grid_y}`;
                positionSets.tk.add(key);
                positionSets.all.add(key);
            }
        }
        
        console.log(`Loaded RBMK layout config: ${positionSets.all.size} total cells`);
        console.log(`  AZ: ${positionSets.az.size}, AR: ${positionSets.ar.size}, LAR: ${positionSets.lar.size}`);
        console.log(`  USP: ${positionSets.usp.size}, RR: ${positionSets.rr.size}, TK: ${positionSets.tk.size}`);
    } catch (error) {
        console.error('Failed to load layout config:', error);
        throw error;
    }
}

/**
 * Check if layout config is loaded
 */
export function isLayoutLoaded(): boolean {
    return layoutConfig !== null && positionSets !== null;
}

/**
 * Generate the RBMK-1000 core layout based on loaded JSON config
 * The pattern follows the real RBMK control rod distribution from OPB-82
 */
export function generateRBMKCoreLayout(): CoreChannel[] {
    if (!positionSets) {
        console.warn('Layout config not loaded, returning empty layout');
        return [];
    }
    
    const channels: CoreChannel[] = [];
    let channelId = 0;
    
    // Generate all channels based on positions from JSON config
    for (let gx = 0; gx < GRID_SIZE; gx++) {
        for (let gy = 0; gy < GRID_SIZE; gy++) {
            const key = `${gx},${gy}`;
            
            // Skip positions that are not in the core (use actual boundary from config)
            if (!positionSets.all.has(key)) continue;
            
            // Calculate position from center
            const cx = (gx - GRID_SIZE / 2 + 0.5) * GRID_SPACING;
            const cy = (gy - GRID_SIZE / 2 + 0.5) * GRID_SPACING;
            
            let type: ChannelType;
            
            if (positionSets.az.has(key)) {
                type = 'AZ';
            } else if (positionSets.ar.has(key)) {
                type = 'AR';
            } else if (positionSets.lar.has(key)) {
                type = 'LAR';
            } else if (positionSets.usp.has(key)) {
                type = 'USP';
            } else if (positionSets.rr.has(key)) {
                type = 'RR';
            } else {
                type = 'TK';  // Everything else is fuel
            }
            
            channels.push({
                id: channelId++,
                type,
                gridX: gx,
                gridY: gy,
                x: cx,
                y: cy,
            });
        }
    }
    
    return channels;
}

/**
 * Get channel counts by type
 */
export function getChannelCounts(channels: CoreChannel[]): Record<ChannelType, number> {
    const counts: Record<ChannelType, number> = {
        TK: 0, RR: 0, AR: 0, USP: 0, LAR: 0, AZ: 0, GRAPHITE: 0
    };
    
    for (const ch of channels) {
        counts[ch.type]++;
    }
    
    return counts;
}

/**
 * Get channels by type
 */
export function getChannelsByType(channels: CoreChannel[], type: ChannelType): CoreChannel[] {
    return channels.filter(ch => ch.type === type);
}

/**
 * Convert channel type to rod_type string for backend
 */
export function channelTypeToRodType(type: ChannelType): string {
    switch (type) {
        case 'AZ': return 'Emergency';
        case 'AR': return 'Automatic';
        case 'LAR': return 'Automatic';  // LAR behaves like AR
        case 'USP': return 'Shortened';
        case 'RR': return 'Manual';
        default: return 'Manual';
    }
}

/**
 * Get raw layout config (for debugging)
 */
export function getLayoutConfig(): LayoutConfig | null {
    return layoutConfig;
}
